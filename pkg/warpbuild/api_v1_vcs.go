/*
Warp Builds API Docs

This is the docs for warp builds api for argonaut

API version: 0.4.0
Contact: support@swagger.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package warpbuild

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


<<<<<<< HEAD
type V1VcsAPI interface {
=======
type V1VcsApi interface {
>>>>>>> prajjwal-warp-323

	/*
	ApproveVCSIntegration This handles the callback for approving an installation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApproveVCSIntegrationRequest
	*/
	ApproveVCSIntegration(ctx context.Context) ApiApproveVCSIntegrationRequest

	// ApproveVCSIntegrationExecute executes the request
	//  @return AuthUserResponse
	ApproveVCSIntegrationExecute(r ApiApproveVCSIntegrationRequest) (*AuthUserResponse, *http.Response, error)

	/*
	CreateVCSGitRepo create vcs repo based on repo internal id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateVCSGitRepoRequest
	*/
	CreateVCSGitRepo(ctx context.Context) ApiCreateVCSGitRepoRequest

	// CreateVCSGitRepoExecute executes the request
	//  @return CommonsRepo
	CreateVCSGitRepoExecute(r ApiCreateVCSGitRepoRequest) (*CommonsRepo, *http.Response, error)

	/*
	CreateVCSIntegration Create a new vcs integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateVCSIntegrationRequest
	*/
	CreateVCSIntegration(ctx context.Context) ApiCreateVCSIntegrationRequest

	// CreateVCSIntegrationExecute executes the request
	//  @return VCSIntegration
	CreateVCSIntegrationExecute(r ApiCreateVCSIntegrationRequest) (*VCSIntegration, *http.Response, error)

	/*
	DeleteVCSIntegration Delete an existing vcs integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationId ID for the vcs integration
	@return ApiDeleteVCSIntegrationRequest
	*/
	DeleteVCSIntegration(ctx context.Context, integrationId string) ApiDeleteVCSIntegrationRequest

	// DeleteVCSIntegrationExecute executes the request
	//  @return TypesGenericSuccessMessage
	DeleteVCSIntegrationExecute(r ApiDeleteVCSIntegrationRequest) (*TypesGenericSuccessMessage, *http.Response, error)

	/*
	GetVCSGitRepo get vcs repo based on repo internal id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id internal id for the vcs git repo
	@return ApiGetVCSGitRepoRequest
	*/
	GetVCSGitRepo(ctx context.Context, id string) ApiGetVCSGitRepoRequest

	// GetVCSGitRepoExecute executes the request
	//  @return CommonsRepo
	GetVCSGitRepoExecute(r ApiGetVCSGitRepoRequest) (*CommonsRepo, *http.Response, error)

	/*
	ListVCSEntites Lists all vcs entities for vcs integration

	VCS Entities refers to git entites like git repos, git branches, etc.
This endpoint is a commons endpoint to fetch these.
ParentID is required depending on what git entity you are fetching.

Git entity heirchary:
Git Organization > Git Repository > Git Branch

When fetching an entity the parent id is the id of git entity one level above
So for example, fetching repository will be
http://backend.warpbuild.com/api/v1/vcs/entities?provider=gitlab&entity_type=repository&parent_id=organization_external_id
For the most top level entity there is no parent_id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListVCSEntitesRequest
	*/
	ListVCSEntites(ctx context.Context) ApiListVCSEntitesRequest

	// ListVCSEntitesExecute executes the request
	//  @return []VCSEntity
	ListVCSEntitesExecute(r ApiListVCSEntitesRequest) ([]VCSEntity, *http.Response, error)

	/*
	ListVCSIntegration Lists all vcs integration for provider

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListVCSIntegrationRequest
	*/
	ListVCSIntegration(ctx context.Context) ApiListVCSIntegrationRequest

	// ListVCSIntegrationExecute executes the request
	//  @return []VCSIntegration
	ListVCSIntegrationExecute(r ApiListVCSIntegrationRequest) ([]VCSIntegration, *http.Response, error)

	/*
<<<<<<< HEAD
=======
	ListVCSRepos Lists all vcs repos for vcs integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListVCSReposRequest
	*/
	ListVCSRepos(ctx context.Context) ApiListVCSReposRequest

	// ListVCSReposExecute executes the request
	//  @return []CommonsRepo
	ListVCSReposExecute(r ApiListVCSReposRequest) ([]CommonsRepo, *http.Response, error)

	/*
	ListVCSRunnerGroups Lists all vcs runner groups

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListVCSRunnerGroupsRequest
	*/
	ListVCSRunnerGroups(ctx context.Context) ApiListVCSRunnerGroupsRequest

	// ListVCSRunnerGroupsExecute executes the request
	//  @return CommonsListVCSRunnerGroupsResponse
	ListVCSRunnerGroupsExecute(r ApiListVCSRunnerGroupsRequest) (*CommonsListVCSRunnerGroupsResponse, *http.Response, error)

	/*
>>>>>>> prajjwal-warp-323
	UpdateVCSIntegration Update an existing vcs integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationId ID for the vcs integration
	@return ApiUpdateVCSIntegrationRequest
	*/
	UpdateVCSIntegration(ctx context.Context, integrationId string) ApiUpdateVCSIntegrationRequest

	// UpdateVCSIntegrationExecute executes the request
	//  @return UpdateVCSIntegrationResponse
	UpdateVCSIntegrationExecute(r ApiUpdateVCSIntegrationRequest) (*UpdateVCSIntegrationResponse, *http.Response, error)
}

<<<<<<< HEAD
// V1VcsAPIService V1VcsAPI service
type V1VcsAPIService service

type ApiApproveVCSIntegrationRequest struct {
	ctx context.Context
	ApiService V1VcsAPI
=======
// V1VcsApiService V1VcsApi service
type V1VcsApiService service

type ApiApproveVCSIntegrationRequest struct {
	ctx context.Context
	ApiService V1VcsApi
>>>>>>> prajjwal-warp-323
	body *ApproveVCSIntegrationRequest
}

// Approve vcs integration app installation
func (r ApiApproveVCSIntegrationRequest) Body(body ApproveVCSIntegrationRequest) ApiApproveVCSIntegrationRequest {
	r.body = &body
	return r
}

func (r ApiApproveVCSIntegrationRequest) Execute() (*AuthUserResponse, *http.Response, error) {
	return r.ApiService.ApproveVCSIntegrationExecute(r)
}

/*
ApproveVCSIntegration This handles the callback for approving an installation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApproveVCSIntegrationRequest
*/
<<<<<<< HEAD
func (a *V1VcsAPIService) ApproveVCSIntegration(ctx context.Context) ApiApproveVCSIntegrationRequest {
=======
func (a *V1VcsApiService) ApproveVCSIntegration(ctx context.Context) ApiApproveVCSIntegrationRequest {
>>>>>>> prajjwal-warp-323
	return ApiApproveVCSIntegrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthUserResponse
<<<<<<< HEAD
func (a *V1VcsAPIService) ApproveVCSIntegrationExecute(r ApiApproveVCSIntegrationRequest) (*AuthUserResponse, *http.Response, error) {
=======
func (a *V1VcsApiService) ApproveVCSIntegrationExecute(r ApiApproveVCSIntegrationRequest) (*AuthUserResponse, *http.Response, error) {
>>>>>>> prajjwal-warp-323
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthUserResponse
	)

<<<<<<< HEAD
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1VcsAPIService.ApproveVCSIntegration")
=======
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1VcsApiService.ApproveVCSIntegration")
>>>>>>> prajjwal-warp-323
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vcs/approve-integration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVCSGitRepoRequest struct {
	ctx context.Context
<<<<<<< HEAD
	ApiService V1VcsAPI
=======
	ApiService V1VcsApi
>>>>>>> prajjwal-warp-323
	body *CommonsCreateRepoOptions
}

// create repo options
func (r ApiCreateVCSGitRepoRequest) Body(body CommonsCreateRepoOptions) ApiCreateVCSGitRepoRequest {
	r.body = &body
	return r
}

func (r ApiCreateVCSGitRepoRequest) Execute() (*CommonsRepo, *http.Response, error) {
	return r.ApiService.CreateVCSGitRepoExecute(r)
}

/*
CreateVCSGitRepo create vcs repo based on repo internal id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateVCSGitRepoRequest
*/
<<<<<<< HEAD
func (a *V1VcsAPIService) CreateVCSGitRepo(ctx context.Context) ApiCreateVCSGitRepoRequest {
=======
func (a *V1VcsApiService) CreateVCSGitRepo(ctx context.Context) ApiCreateVCSGitRepoRequest {
>>>>>>> prajjwal-warp-323
	return ApiCreateVCSGitRepoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CommonsRepo
<<<<<<< HEAD
func (a *V1VcsAPIService) CreateVCSGitRepoExecute(r ApiCreateVCSGitRepoRequest) (*CommonsRepo, *http.Response, error) {
=======
func (a *V1VcsApiService) CreateVCSGitRepoExecute(r ApiCreateVCSGitRepoRequest) (*CommonsRepo, *http.Response, error) {
>>>>>>> prajjwal-warp-323
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CommonsRepo
	)

<<<<<<< HEAD
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1VcsAPIService.CreateVCSGitRepo")
=======
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1VcsApiService.CreateVCSGitRepo")
>>>>>>> prajjwal-warp-323
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vcs/repos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVCSIntegrationRequest struct {
	ctx context.Context
<<<<<<< HEAD
	ApiService V1VcsAPI
=======
	ApiService V1VcsApi
>>>>>>> prajjwal-warp-323
	body *CreateVCSIntegrationRequest
}

// Create new vcs integration body
func (r ApiCreateVCSIntegrationRequest) Body(body CreateVCSIntegrationRequest) ApiCreateVCSIntegrationRequest {
	r.body = &body
	return r
}

func (r ApiCreateVCSIntegrationRequest) Execute() (*VCSIntegration, *http.Response, error) {
	return r.ApiService.CreateVCSIntegrationExecute(r)
}

/*
CreateVCSIntegration Create a new vcs integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateVCSIntegrationRequest
*/
<<<<<<< HEAD
func (a *V1VcsAPIService) CreateVCSIntegration(ctx context.Context) ApiCreateVCSIntegrationRequest {
=======
func (a *V1VcsApiService) CreateVCSIntegration(ctx context.Context) ApiCreateVCSIntegrationRequest {
>>>>>>> prajjwal-warp-323
	return ApiCreateVCSIntegrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VCSIntegration
<<<<<<< HEAD
func (a *V1VcsAPIService) CreateVCSIntegrationExecute(r ApiCreateVCSIntegrationRequest) (*VCSIntegration, *http.Response, error) {
=======
func (a *V1VcsApiService) CreateVCSIntegrationExecute(r ApiCreateVCSIntegrationRequest) (*VCSIntegration, *http.Response, error) {
>>>>>>> prajjwal-warp-323
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VCSIntegration
	)

<<<<<<< HEAD
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1VcsAPIService.CreateVCSIntegration")
=======
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1VcsApiService.CreateVCSIntegration")
>>>>>>> prajjwal-warp-323
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vcs/integrations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteVCSIntegrationRequest struct {
	ctx context.Context
<<<<<<< HEAD
	ApiService V1VcsAPI
=======
	ApiService V1VcsApi
>>>>>>> prajjwal-warp-323
	integrationId string
	provider *string
}

// ID for the vcs integration
func (r ApiDeleteVCSIntegrationRequest) Provider(provider string) ApiDeleteVCSIntegrationRequest {
	r.provider = &provider
	return r
}

func (r ApiDeleteVCSIntegrationRequest) Execute() (*TypesGenericSuccessMessage, *http.Response, error) {
	return r.ApiService.DeleteVCSIntegrationExecute(r)
}

/*
DeleteVCSIntegration Delete an existing vcs integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationId ID for the vcs integration
 @return ApiDeleteVCSIntegrationRequest
*/
<<<<<<< HEAD
func (a *V1VcsAPIService) DeleteVCSIntegration(ctx context.Context, integrationId string) ApiDeleteVCSIntegrationRequest {
=======
func (a *V1VcsApiService) DeleteVCSIntegration(ctx context.Context, integrationId string) ApiDeleteVCSIntegrationRequest {
>>>>>>> prajjwal-warp-323
	return ApiDeleteVCSIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		integrationId: integrationId,
	}
}

// Execute executes the request
//  @return TypesGenericSuccessMessage
<<<<<<< HEAD
func (a *V1VcsAPIService) DeleteVCSIntegrationExecute(r ApiDeleteVCSIntegrationRequest) (*TypesGenericSuccessMessage, *http.Response, error) {
=======
func (a *V1VcsApiService) DeleteVCSIntegrationExecute(r ApiDeleteVCSIntegrationRequest) (*TypesGenericSuccessMessage, *http.Response, error) {
>>>>>>> prajjwal-warp-323
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TypesGenericSuccessMessage
	)

<<<<<<< HEAD
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1VcsAPIService.DeleteVCSIntegration")
=======
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1VcsApiService.DeleteVCSIntegration")
>>>>>>> prajjwal-warp-323
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vcs/integrations/{integration_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"integration_id"+"}", url.PathEscape(parameterValueToString(r.integrationId, "integrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.provider == nil {
		return localVarReturnValue, nil, reportError("provider is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "provider", r.provider, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVCSGitRepoRequest struct {
	ctx context.Context
<<<<<<< HEAD
	ApiService V1VcsAPI
=======
	ApiService V1VcsApi
>>>>>>> prajjwal-warp-323
	id string
}

func (r ApiGetVCSGitRepoRequest) Execute() (*CommonsRepo, *http.Response, error) {
	return r.ApiService.GetVCSGitRepoExecute(r)
}

/*
GetVCSGitRepo get vcs repo based on repo internal id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id internal id for the vcs git repo
 @return ApiGetVCSGitRepoRequest
*/
<<<<<<< HEAD
func (a *V1VcsAPIService) GetVCSGitRepo(ctx context.Context, id string) ApiGetVCSGitRepoRequest {
=======
func (a *V1VcsApiService) GetVCSGitRepo(ctx context.Context, id string) ApiGetVCSGitRepoRequest {
>>>>>>> prajjwal-warp-323
	return ApiGetVCSGitRepoRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CommonsRepo
<<<<<<< HEAD
func (a *V1VcsAPIService) GetVCSGitRepoExecute(r ApiGetVCSGitRepoRequest) (*CommonsRepo, *http.Response, error) {
=======
func (a *V1VcsApiService) GetVCSGitRepoExecute(r ApiGetVCSGitRepoRequest) (*CommonsRepo, *http.Response, error) {
>>>>>>> prajjwal-warp-323
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CommonsRepo
	)

<<<<<<< HEAD
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1VcsAPIService.GetVCSGitRepo")
=======
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1VcsApiService.GetVCSGitRepo")
>>>>>>> prajjwal-warp-323
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vcs/repos/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVCSEntitesRequest struct {
	ctx context.Context
<<<<<<< HEAD
	ApiService V1VcsAPI
=======
	ApiService V1VcsApi
>>>>>>> prajjwal-warp-323
	entityType *string
	provider *string
	name *string
	integrationId *string
	parentId *string
}

// VCS Entity that should be returned
func (r ApiListVCSEntitesRequest) EntityType(entityType string) ApiListVCSEntitesRequest {
	r.entityType = &entityType
	return r
}

// Git provider
func (r ApiListVCSEntitesRequest) Provider(provider string) ApiListVCSEntitesRequest {
	r.provider = &provider
	return r
}

// Filter using organization name
func (r ApiListVCSEntitesRequest) Name(name string) ApiListVCSEntitesRequest {
	r.name = &name
	return r
}

// IntegrationID used by the git provider
func (r ApiListVCSEntitesRequest) IntegrationId(integrationId string) ApiListVCSEntitesRequest {
	r.integrationId = &integrationId
	return r
}

// VCS Entity Parent ID
func (r ApiListVCSEntitesRequest) ParentId(parentId string) ApiListVCSEntitesRequest {
	r.parentId = &parentId
	return r
}

func (r ApiListVCSEntitesRequest) Execute() ([]VCSEntity, *http.Response, error) {
	return r.ApiService.ListVCSEntitesExecute(r)
}

/*
ListVCSEntites Lists all vcs entities for vcs integration

VCS Entities refers to git entites like git repos, git branches, etc.
This endpoint is a commons endpoint to fetch these.
ParentID is required depending on what git entity you are fetching.

Git entity heirchary:
Git Organization > Git Repository > Git Branch

When fetching an entity the parent id is the id of git entity one level above
So for example, fetching repository will be
http://backend.warpbuild.com/api/v1/vcs/entities?provider=gitlab&entity_type=repository&parent_id=organization_external_id
For the most top level entity there is no parent_id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListVCSEntitesRequest
*/
<<<<<<< HEAD
func (a *V1VcsAPIService) ListVCSEntites(ctx context.Context) ApiListVCSEntitesRequest {
=======
func (a *V1VcsApiService) ListVCSEntites(ctx context.Context) ApiListVCSEntitesRequest {
>>>>>>> prajjwal-warp-323
	return ApiListVCSEntitesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VCSEntity
<<<<<<< HEAD
func (a *V1VcsAPIService) ListVCSEntitesExecute(r ApiListVCSEntitesRequest) ([]VCSEntity, *http.Response, error) {
=======
func (a *V1VcsApiService) ListVCSEntitesExecute(r ApiListVCSEntitesRequest) ([]VCSEntity, *http.Response, error) {
>>>>>>> prajjwal-warp-323
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VCSEntity
	)

<<<<<<< HEAD
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1VcsAPIService.ListVCSEntites")
=======
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1VcsApiService.ListVCSEntites")
>>>>>>> prajjwal-warp-323
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vcs/entities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.entityType == nil {
		return localVarReturnValue, nil, reportError("entityType is required and must be specified")
	}

	if r.provider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider", r.provider, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integration_id", r.integrationId, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "entity_type", r.entityType, "")
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_id", r.parentId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVCSIntegrationRequest struct {
	ctx context.Context
<<<<<<< HEAD
	ApiService V1VcsAPI
=======
	ApiService V1VcsApi
>>>>>>> prajjwal-warp-323
	provider *string
	status *string
}

// vcs integration provider filter
func (r ApiListVCSIntegrationRequest) Provider(provider string) ApiListVCSIntegrationRequest {
	r.provider = &provider
	return r
}

// vcs integration provider filter
func (r ApiListVCSIntegrationRequest) Status(status string) ApiListVCSIntegrationRequest {
	r.status = &status
	return r
}

func (r ApiListVCSIntegrationRequest) Execute() ([]VCSIntegration, *http.Response, error) {
	return r.ApiService.ListVCSIntegrationExecute(r)
}

/*
ListVCSIntegration Lists all vcs integration for provider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListVCSIntegrationRequest
*/
<<<<<<< HEAD
func (a *V1VcsAPIService) ListVCSIntegration(ctx context.Context) ApiListVCSIntegrationRequest {
=======
func (a *V1VcsApiService) ListVCSIntegration(ctx context.Context) ApiListVCSIntegrationRequest {
>>>>>>> prajjwal-warp-323
	return ApiListVCSIntegrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VCSIntegration
<<<<<<< HEAD
func (a *V1VcsAPIService) ListVCSIntegrationExecute(r ApiListVCSIntegrationRequest) ([]VCSIntegration, *http.Response, error) {
=======
func (a *V1VcsApiService) ListVCSIntegrationExecute(r ApiListVCSIntegrationRequest) ([]VCSIntegration, *http.Response, error) {
>>>>>>> prajjwal-warp-323
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VCSIntegration
	)

<<<<<<< HEAD
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1VcsAPIService.ListVCSIntegration")
=======
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1VcsApiService.ListVCSIntegration")
>>>>>>> prajjwal-warp-323
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vcs/integrations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.provider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider", r.provider, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

<<<<<<< HEAD
type ApiUpdateVCSIntegrationRequest struct {
	ctx context.Context
	ApiService V1VcsAPI
=======
type ApiListVCSReposRequest struct {
	ctx context.Context
	ApiService V1VcsApi
}

func (r ApiListVCSReposRequest) Execute() ([]CommonsRepo, *http.Response, error) {
	return r.ApiService.ListVCSReposExecute(r)
}

/*
ListVCSRepos Lists all vcs repos for vcs integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListVCSReposRequest
*/
func (a *V1VcsApiService) ListVCSRepos(ctx context.Context) ApiListVCSReposRequest {
	return ApiListVCSReposRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CommonsRepo
func (a *V1VcsApiService) ListVCSReposExecute(r ApiListVCSReposRequest) ([]CommonsRepo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CommonsRepo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1VcsApiService.ListVCSRepos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vcs/repos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVCSRunnerGroupsRequest struct {
	ctx context.Context
	ApiService V1VcsApi
	body *CommonsListVCSRunnerGroupsInput
}

// List runner groups input
func (r ApiListVCSRunnerGroupsRequest) Body(body CommonsListVCSRunnerGroupsInput) ApiListVCSRunnerGroupsRequest {
	r.body = &body
	return r
}

func (r ApiListVCSRunnerGroupsRequest) Execute() (*CommonsListVCSRunnerGroupsResponse, *http.Response, error) {
	return r.ApiService.ListVCSRunnerGroupsExecute(r)
}

/*
ListVCSRunnerGroups Lists all vcs runner groups

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListVCSRunnerGroupsRequest
*/
func (a *V1VcsApiService) ListVCSRunnerGroups(ctx context.Context) ApiListVCSRunnerGroupsRequest {
	return ApiListVCSRunnerGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CommonsListVCSRunnerGroupsResponse
func (a *V1VcsApiService) ListVCSRunnerGroupsExecute(r ApiListVCSRunnerGroupsRequest) (*CommonsListVCSRunnerGroupsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CommonsListVCSRunnerGroupsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1VcsApiService.ListVCSRunnerGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vcs/list-runner-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateVCSIntegrationRequest struct {
	ctx context.Context
	ApiService V1VcsApi
>>>>>>> prajjwal-warp-323
	integrationId string
	body *UpdateVCSIntegrationRequest
}

// Update vcs integration body
func (r ApiUpdateVCSIntegrationRequest) Body(body UpdateVCSIntegrationRequest) ApiUpdateVCSIntegrationRequest {
	r.body = &body
	return r
}

func (r ApiUpdateVCSIntegrationRequest) Execute() (*UpdateVCSIntegrationResponse, *http.Response, error) {
	return r.ApiService.UpdateVCSIntegrationExecute(r)
}

/*
UpdateVCSIntegration Update an existing vcs integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationId ID for the vcs integration
 @return ApiUpdateVCSIntegrationRequest
*/
<<<<<<< HEAD
func (a *V1VcsAPIService) UpdateVCSIntegration(ctx context.Context, integrationId string) ApiUpdateVCSIntegrationRequest {
=======
func (a *V1VcsApiService) UpdateVCSIntegration(ctx context.Context, integrationId string) ApiUpdateVCSIntegrationRequest {
>>>>>>> prajjwal-warp-323
	return ApiUpdateVCSIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		integrationId: integrationId,
	}
}

// Execute executes the request
//  @return UpdateVCSIntegrationResponse
<<<<<<< HEAD
func (a *V1VcsAPIService) UpdateVCSIntegrationExecute(r ApiUpdateVCSIntegrationRequest) (*UpdateVCSIntegrationResponse, *http.Response, error) {
=======
func (a *V1VcsApiService) UpdateVCSIntegrationExecute(r ApiUpdateVCSIntegrationRequest) (*UpdateVCSIntegrationResponse, *http.Response, error) {
>>>>>>> prajjwal-warp-323
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateVCSIntegrationResponse
	)

<<<<<<< HEAD
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1VcsAPIService.UpdateVCSIntegration")
=======
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1VcsApiService.UpdateVCSIntegration")
>>>>>>> prajjwal-warp-323
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vcs/integrations/{integration_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"integration_id"+"}", url.PathEscape(parameterValueToString(r.integrationId, "integrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WarpBuildAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
